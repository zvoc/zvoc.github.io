<html>
  <body>
  </body>
  <script>
  const backCameraKeywords = [
    "rear",
    "back",
    "rück",
    "arrière",
    "trasera",
    "trás",
    "traseira",
    "posteriore",
    "后面",
    "後面",
    "背面",
    "后置", // alternative
    "後置", // alternative
    "背置", // alternative
    "задней",
    "الخلفية",
    "후",
    "arka",
    "achterzijde",
    "หลัง",
    "baksidan",
    "bagside",
    "sau",
    "bak",
    "tylny",
    "takakamera",
    "belakang",
    "אחורית",
    "πίσω",
    "spate",
    "hátsó",
    "zadní",
    "darrere",
    "zadná",
    "задня",
    "stražnja",
    "belakang",
    "बैक",
  ];
	  
  function isBackCameraLabel(label) {
    const lowercaseLabel = label.toLowerCase();

    return backCameraKeywords.some((keyword) => {
      return lowercaseLabel.includes(keyword);
    });
  }
    /**
   * @hidden
   *
   * Map non-standard error names to standard ones.
   *
   * @param error The error object.
   */
  function mapNonStandardErrorName(error) {
    let name = error.name;
    
    switch (name) {
      case "DeviceCaptureError":
      case "ScreenCaptureError":
      case "TabCaptureError":
        name = "AbortError";
        break;
      case "InvalidStateError":
      case "MediaDeviceFailedDueToShutdown":
      case "MediaDeviceKillSwitchOn":
      case "PermissionDeniedError":
      case "PermissionDismissedError":
        name = "NotAllowedError";
        break;
      case "DevicesNotFoundError":
        name = "NotFoundError";
        break;
      case "SourceUnavailableError":
      case "TrackStartError":
        name = "NotReadableError";
        break;
      case "ConstraintNotSatisfiedError":
        name = "OverconstrainedError";
        break;
      default:
        return;
    }
    Object.defineProperty(error, "name", {
      value: name,
    });
  }

  async function getBestCamera(idealWidth, idealHeight) {
	  
    document.write("1<br>");

    try {
      const stream = await navigator.mediaDevices.getUserMedia( { video: { width: { min: 320, ideal: 640, }, height: { min: 240, ideal: 480, }, facingMode: { ideal: 'environment' } } } );
	    document.write("2<br>");
      stream.getTracks().forEach( track => track.stop() );
    } catch (err) {
      mapNonStandardErrorName(err);
      handleGetUserMediaError(err);
      return;
    }
    try {
    const devices = await navigator.mediaDevices.enumerateDevices();
    let videoDevices = [];
	    document.write("3<br>");
    devices.forEach( ( device ) => {
      if ( device.kind == 'videoinput' ) {
        document.write( "Found video device: " + JSON.stringify( device ) + "<br>" );
	console.log (JSON.stringify( device ));
        videoDevices.push( device );
      }
    });

    for ( let i = videoDevices.length - 1; i >= 0; i-- ) {
	    document.write("4<br>");
      const device = videoDevices[ i ];
      document.write( "Opening video device " + device.deviceId + " (" + device.label + ")"  + "<br>");
      try {
        const stream = await navigator.mediaDevices.getUserMedia( { video: { deviceId: { exact: device.deviceId }, width: { min: 320, ideal: 640, }, height: { min: 240, ideal: 480, }, facingMode: { ideal: 'environment' } } } );

        let track = stream.getVideoTracks()[0];
        let capabilities;
	      
	if (typeof track.getCapabilities === "function") {
	    capabilities = track.getCapabilities();  
	}
        document.write( "Track capabilities: " + JSON.stringify( capabilities )  + "<br>");
	console.log( "Track capabilities: " + JSON.stringify( capabilities )  + "<br>");
	      
        if ( capabilities == undefined || capabilities != undefined && capabilities.facingMode[0] === 'environment' || (device.label != undefined && isBackCameraLabel(device.label))) {
          cameraFound( stream );
          return;
        }
	stream.getTracks().forEach( track => track.stop() );
      } catch (err) {
        handleGetUserMediaError(err);
      }
    }

    for ( let i = 0; i < videoDevices.length; i-- ) {
      const device = videoDevices[ i ];
      document.write( "Opening video device " + device.deviceId + " (" + device.label + ")"  + "<br>");
      try {
        const stream = await navigator.mediaDevices.getUserMedia( { video: { deviceId: { exact: device.deviceId }, width: { ideal: idealWidth }, height: { ideal: idealHeight }, facingMode: { ideal: 'environment' } } } );

        let track = stream.getVideoTracks()[0];
        let capabilities;
	      
	if (typeof track.getCapabilities === "function") {
	    capabilities = track.getCapabilities();  
	}
        document.write( "Track capabilities: " + JSON.stringify( capabilities )  + "<br>");
      
        cameraFound( stream );
        return;
      } catch (err) {
        handleGetUserMediaError(err);
      }
    }
    } catch (err) {
      handleGetUserMediaError(err);
    }
  }

  function handleGetUserMediaError(err) {
    document.write("Get user media error: " + err.name + " - " + err.message + "<br>");
  }

  function cameraFound( stream ) {
    document.write("FOUND");
  }
	  
  getBestCamera(640, 480)
	  
  </script>
</html>
