<html>
  <body>
  </body>
  <script>
	  
    /**
   * @hidden
   *
   * Map non-standard error names to standard ones.
   *
   * @param error The error object.
   */
  function mapNonStandardErrorName(error) {
    let name = error.name;
    
    switch (name) {
      case "DeviceCaptureError":
      case "ScreenCaptureError":
      case "TabCaptureError":
        name = "AbortError";
        break;
      case "InvalidStateError":
      case "MediaDeviceFailedDueToShutdown":
      case "MediaDeviceKillSwitchOn":
      case "PermissionDeniedError":
      case "PermissionDismissedError":
        name = "NotAllowedError";
        break;
      case "DevicesNotFoundError":
        name = "NotFoundError";
        break;
      case "SourceUnavailableError":
      case "TrackStartError":
        name = "NotReadableError";
        break;
      case "ConstraintNotSatisfiedError":
        name = "OverconstrainedError";
        break;
      default:
        return;
    }
    Object.defineProperty(error, "name", {
      value: name,
    });
  }

  async function getBestCamera(idealWidth, idealHeight) {

    try {
      const stream2 = await navigator.mediaDevices.getUserMedia( { video: true } );
      stream2.getTracks().forEach( track => track.stop() );
    } catch (err) {
      mapNonStandardErrorName(err);
      handleGetUserMediaError(err);
      return;
    }

    const devices = await navigator.mediaDevices.enumerateDevices();
    let videoDevices = [];
    devices.forEach( ( device ) => {
      if ( device.kind == 'videoinput' ) {
        document.write( "Found video device: " + JSON.stringify( device ) + "<br>" );
        videoDevices.push( device );
      }
    });

    for ( let i = videoDevices.length - 1; i >= 0; i-- ) {
      const device = videoDevices[ i ];
      document.write( "Opening video device " + device.deviceId + " (" + device.label + ")"  + "<br>");
      try {
        const stream = await navigator.mediaDevices.getUserMedia( { video: { deviceId: { exact: device.deviceId }, width: { ideal: idealWidth }, height: { ideal: idealHeight }, facingMode: { ideal: 'environment' } } } );

        let track = stream.getVideoTracks()[0];
        const capabilities = track.getCapabilities();
        document.write( "Track capabilities: " + JSON.stringify( capabilities )  + "<br>");
        if (capabilities.facingMode.length === 0 || capabilities.facingMode[0] === 'environment' ) {
          cameraFound( stream );
          return;
        }
      } catch (err) {
        handleGetUserMediaError(err);
      }
    }

    for ( let i = 0; i < videoDevices.length; i-- ) {
      const device = videoDevices[ i ];
      document.write( "Opening video device " + device.deviceId + " (" + device.label + ")"  + "<br>");
      try {
        const stream = await navigator.mediaDevices.getUserMedia( { video: { deviceId: { exact: device.deviceId }, width: { ideal: idealWidth }, height: { ideal: idealHeight }, facingMode: { ideal: 'environment' } } } );

        let track = stream.getVideoTracks()[0];
        const capabilities = track.getCapabilities();
        document.write( "Track capabilities: " + JSON.stringify( capabilities )  + "<br>");
      
        cameraFound( stream );
        return;
      } catch (err) {
        handleGetUserMediaError(err);
      }
    }
  }

  function handleGetUserMediaError(err) {
    document.write("Get user media error: " + err.name + " - " + err.message + "<br>");
  }

  function cameraFound( stream ) {
    document.write("FOUND");
  }
	  
  getBestCamera(640, 480)
	  
  </script>
</html>
